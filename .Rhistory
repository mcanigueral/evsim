n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
sessions_socket <- sessions_socket %>%
drop_na(.data$ChargingSocket) %>%
separate(.data$ChargingSocket, into = c("ChargingStation", "Socket"), sep = "-")
message(paste("Discarded", round((1-nrow(sessions_socket)/nrow(sessions))*100, 2), "% of sessions due to infrastructure"))
nrow(sessions_socket)
add_charging_infrastructure(sessions, connections_th = 0)
#'
#' @return tibble
#' @export
#'
#' @importFrom dplyr %>% tibble mutate select all_of row_number filter group_by summarise
#' @importFrom tidyr separate drop_na
#' @importFrom lubridate as_datetime tz
#' @importFrom purrr map_dbl
#' @importFrom rlang .data
#'
add_charging_infrastructure <- function(sessions, resolution = 15, min_stations = 0, names_prefix = NULL, connections_th = 10) {
# How many charging stations (of two sockets) do we need?
connections <- sessions %>%
mutate(Profile = "n_connections") %>%
get_n_connections(resolution = resolution, by = "Profile")
connections_pct <- tibble(
n_connections = seq(1, max(connections$n_connections))
) %>%
mutate(
n = map_dbl(.data$n_connections, ~ sum(connections$n_connections >= .x)),
pct = n/nrow(connections)*100
)
n_connections_required <- connections_pct %>%
filter(.data$pct > connections_th)
n_required_stations <- ceiling(max(n_connections_required$n_connections)/2)
if (n_required_stations < min_stations) {
n_required_stations <- min_stations
}
# Name the charging stations and the corresponding sockets
if (is.null(names_prefix)) {
names_prefix <- ""
}
new_stations_names <- paste(names_prefix, 1:n_required_stations, sep = "CHS")
socket_names <- paste(new_stations_names, rep(c(1, 2), each = n_required_stations), sep = "-")
# Iterate over all time slots assigning every session to a charging socket
free_sockets <- socket_names
sessions_socket <- sessions %>% mutate(idx = row_number())
sessions_socket$ChargingSocket <- NA
dttm_seq <- sort(unique(c(sessions$ConnectionStartDateTime, sessions$ConnectionEndDateTime)))
for (dttm in dttm_seq) {
# dttm <- connections$datetime[60]
# Add the sockets of ending sessions to the vector of free sockets
ending_sessions <- sessions_socket %>%
filter(
.data$ConnectionEndDateTime == dttm
) %>%
drop_na()
if (nrow(ending_sessions) > 0) {
free_sockets <- c(free_sockets, ending_sessions$ChargingSocket)
}
# Assign to the starting sessions the free sockets
starting_sessions <- sessions_socket %>%
filter(
.data$ConnectionStartDateTime == dttm
)
if (nrow(starting_sessions) > 0) {
n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
sessions_socket <- sessions_socket %>%
drop_na(.data$ChargingSocket) %>%
separate(.data$ChargingSocket, into = c("ChargingStation", "Socket"), sep = "-")
message(paste("Discarded", round((1-nrow(sessions_socket)/nrow(sessions))*100, 2), "% of sessions due to infrastructure"))
return(sessions_socket)
}
add_charging_infrastructure(sessions, connections_th = 0)
usethis::use_test("charging_infrastructure")
# Get the example `evmodel` and `sessions` included in the package
sessions <- evsim::california_ev_sessions %>%
filter(year(ConnectionStartDateTime) == 2018, month(ConnectionStartDateTime) == 10)
test_that("charging infrastructure sizing works", {
sessions_infrastructure <- add_charging_infrastructure(sessions, connections_th = 0)
expect_true(length(unique(sessions_infrastructure$ChargingStation)) > 1)
})
#'
#' @return tibble
#' @export
#'
#' @importFrom dplyr %>% tibble mutate select all_of row_number filter group_by summarise
#' @importFrom tidyr separate drop_na
#' @importFrom lubridate as_datetime tz
#' @importFrom purrr map_dbl
#' @importFrom rlang .data
#'
add_charging_infrastructure <- function(sessions, resolution = 15, min_stations = 0, names_prefix = NULL, connections_th = 10) {
# How many charging stations (of two sockets) do we need?
connections <- sessions %>%
mutate(Profile = "n_connections") %>%
get_n_connections(resolution = resolution, by = "Profile")
connections_pct <- tibble(
n_connections = seq(1, max(connections$n_connections))
) %>%
mutate(
n = map_dbl(.data$n_connections, ~ sum(connections$n_connections >= .x)),
pct = n/nrow(connections)*100
)
n_connections_required <- connections_pct %>%
filter(.data$pct > connections_th)
n_required_stations <- ceiling(max(n_connections_required$n_connections)/2)
if (n_required_stations < min_stations) {
n_required_stations <- min_stations
}
# Name the charging stations and the corresponding sockets
if (is.null(names_prefix)) {
names_prefix <- ""
}
new_stations_names <- paste(names_prefix, 1:n_required_stations, sep = "CHS")
socket_names <- paste(new_stations_names, rep(c(1, 2), each = n_required_stations), sep = "-")
# Iterate over all time slots assigning every session to a charging socket
free_sockets <- socket_names
sessions_socket <- sessions %>% mutate(idx = row_number())
sessions_socket$ChargingSocket <- NA
dttm_seq <- sort(unique(c(sessions$ConnectionStartDateTime, sessions$ConnectionEndDateTime)))
for (dttm in dttm_seq) {
# dttm <- connections$datetime[60]
# Add the sockets of ending sessions to the vector of free sockets
ending_sessions <- sessions_socket %>%
filter(
.data$ConnectionEndDateTime == dttm
) %>%
drop_na()
if (nrow(ending_sessions) > 0) {
free_sockets <- c(free_sockets, ending_sessions$ChargingSocket)
}
# Assign to the starting sessions the free sockets
starting_sessions <- sessions_socket %>%
filter(
.data$ConnectionStartDateTime == dttm
)
if (nrow(starting_sessions) > 0) {
n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
sessions_socket <- sessions_socket %>%
drop_na("ChargingSocket") %>%
separate("ChargingSocket", into = c("ChargingStation", "Socket"), sep = "-")
message(paste("Discarded", round((1-nrow(sessions_socket)/nrow(sessions))*100, 2), "% of sessions due to infrastructure"))
return(sessions_socket)
}
test_that("charging infrastructure sizing works", {
sessions_infrastructure <- add_charging_infrastructure(sessions, connections_th = 0)
expect_true(length(unique(sessions_infrastructure$ChargingStation)) > 1)
})
usethis::use_testthat()
upd
# Get the example `evmodel` and `sessions` included in the package
ev_model <- evsim::california_ev_model
upd <- get_user_profiles_distribution(ev_model)
upd
expect_equal(c("time_cycle", "profile", "ratio"), colnames(upd))
test_that("User profiles distribution is printed correctly", {
upd <- get_user_profiles_distribution(ev_model)
expect_equal(c("time_cycle", "profile", "ratio"), colnames(upd))
})
devtools::spell_check()
goodpractice::gp()
seq(1:5)
1:5
seq_len(5)
goodpractice::gp()
usethis::use_github_action("test-coverage")
library(covr)
covr::codecov(token = "6767f211-6948-4df9-817a-9fa76b67fdd7")
charging_rates <- sessions %>%
get_charging_rates_distribution()
charging_rates
expect_true(nrow(charging_rates) > 1)
ev_model$models
ev_model$models$user_profiles[[1]]
ev_model$models$user_profiles[[1]]$energy_models[[1]]
# Modify to assume that energy models from Worktime are for 11 kW
ev_model$models$user_profiles[[2]]$energy_models
# Modify to assume that energy models from Worktime are for 11 kW
ev_model$models$user_profiles[[2]]$energy_models[[1]]$charging_rate <- 11
ev_model$models$user_profiles[[2]]$energy_models[[1]]
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(15, 10)
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 11, 3.7)
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
simulated_sessions
ev_model$models$user_profiles[[1]]$energy_models
ev_model$models$user_profiles[[1]]
# Modify to assume that energy models from Worktime sessions are for 11 kW
ev_model$models$user_profiles[[1]]$energy_models[[2]]$charging_rate <- 11
ev_model
ev_model$models$user_profiles[[1]]
ev_model$models$user_profiles[[1]]$energy_models
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(15, 10)
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 11, 3.7)
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
simulated_sessions
simulated_sessions %>% filter(Profile == "Worktime", Power < 11)
test_that("demand calculation is skipped if there are no sessions", {
demand <- sessions %>%
mutate(Profile = "All") %>%
filter(Profile == "all") %>%
get_demand(by = "Profile", resolution = 15, dttm_seq = NULL)
expect_true(is.null(demand))
})
test_that("multiprocessing settings are correct", {
demand <- sessions %>%
mutate(Profile = "All") %>%
get_demand(by = "Profile", resolution = 15, mc.cores = 0)
expect_true("All" %in% names(demand))
demand <- sessions %>%
mutate(Profile = "All") %>%
get_demand(by = "Profile", resolution = 15, mc.cores = 10)
expect_true("All" %in% names(demand))
})
devtools::check_win_devel()
devtools::check_rhub()
expect_equal(class(ev_model), "evmodel")
devtools::check_win_devel()
pkgdown::build_site()
pkgdown::build_site()
devtools::check_win_devel()
pkgdown::build_site()
devtools::check_win_devel()
devtools::check_win_devel()
evsim::california_ev_sessions
evsim::california_ev_sessions[100, ]
get_demand(
evsim::california_ev_sessions[100, ],
by = "Session",
resolution = 60
)
library(evsim)
get_demand(
evsim::california_ev_sessions[100, ],
by = "Session",
resolution = 60
)
get_demand(
evsim::california_ev_sessions[1000, ],
by = "Session",
resolution = 60
)
get_demand(
evsim::california_ev_sessions[seq_len(100), ],
by = "Session",
resolution = 60
)
head(evsim::california_ev_sessions, 100)
devtools::check_win_devel()
library(evsim)
library(lubridate)
library(dplyr)
# Get occupancy with the complete datetime sequence from the sessions
sessions <- head(evsim::california_ev_sessions, 100)
get_n_connections(
sessions,
by = "Session",
resolution = 60
)
# Get occupancy with a custom datetime sequence and resolution of 15 minutes
sessions <- head(evsim::california_ev_sessions_profiles, 100)
dttm_seq <- seq.POSIXt(
as_datetime(dmy(01102018)) %>% force_tz(tz(sessions$ConnectionStartDateTime)),
as_datetime(dmy(07102018)) %>% force_tz(tz(sessions$ConnectionStartDateTime)),
by = "15 mins"
)
get_n_connections(
sessions,
dttm_seq = dttm_seq,
by = "Profile",
resolution = 15
)
sessions_infrastructure <- add_charging_infrastructure(
head(evsim::california_ev_sessions, 100), connections_th = 0
)
print(unique(sessions_infrastructure$ChargingStation))
sessions_infrastructure <- add_charging_infrastructure(
head(evsim::california_ev_sessions, 100), resolution = 60, connections_th = 0
)
print(unique(sessions_infrastructure$ChargingStation))
library(evsim)
sessions_infrastructure <- add_charging_infrastructure(
sessions = head(evsim::california_ev_sessions, 100),
resolution = 60, connections_th = 0
)
sessions_infrastructure <- add_charging_infrastructure(
sessions = head(evsim::california_ev_sessions, 50),
resolution = 60, connections_th = 0
)
devtools::check_win_devel()
evsim::california_ev_model$models$user_profiles[[1]]
evsim::california_ev_model$models$user_profiles[[1]]$energy_models
library(testthat)
library(evsim)
library(dplyr)
library(lubridate)
# Get the example `evmodel` and `sessions` included in the package
sessions <- evsim::california_ev_sessions %>%
filter(year(ConnectionStartDateTime) == 2018, month(ConnectionStartDateTime) == 10)
ev_model <- evsim::california_ev_model
test_that("simulation works with charging rates that don't have an energy model", {
# Modify to assume that energy models from Worktime sessions are for 11 kW
ev_model$models$user_profiles[[1]]$energy_models[[2]]$charging_rate <- 11
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(15, 10)
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 22, 3.7) # 22kW is not in the models, but 11kW models are used
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
expect_true(nrow(simulated_sessions) > 0)
})
test_that("simulation works with some user profiles without sessions per day", {
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(15, 0) # No weekend sessions
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 22, 3.7) # 22kW is not in the models, but 11kW models are used
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
expect_true(nrow(simulated_sessions) > 0)
})
simulated_sessions
test_that("simulation is skipped if no sessions per day are configured", {
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(0, 0) # No sessions to simulate
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 22, 3.7) # 22kW is not in the models, but 11kW models are used
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
expect_true(nrow(simulated_sessions) > 0)
})
test_that("simulation is skipped if no sessions per day are configured", {
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(0, 0) # No sessions to simulate
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 22, 3.7) # 22kW is not in the models, but 11kW models are used
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
expect_true(nrow(simulated_sessions) == 0)
})
pkgdown::build_site()
devtools::check_rhub()
get_charging_rates_distribution(evsim::california_sessions)
get_charging_rates_distribution(evsim::california_ev_sessions)
?lubridate::floor_date
#' @export
#'
#' @importFrom dplyr %>% select mutate filter group_by ungroup summarise n all_of
#' @importFrom lubridate floor_date
#' @importFrom rlang .data
#'
#' @examples
#' get_charging_rates_distribution(evsim::california_ev_sessions, unit = "year)
#'
#'
get_charging_rates_distribution <- function(sessions, unit="year") {
sessions_power_round <- sessions %>%
select(all_of(c("ConnectionStartDateTime", "Power"))) %>%
mutate(
power = round_to_interval(.data$Power, 3.7)
) %>%
filter(.data$power > 0)
sessions_power_round$power[sessions_power_round$power >= 11] <- 11
sessions_power_round %>%
group_by(
datetime = floor_date(.data$ConnectionStartDateTime, unit = unit),
power = .data$power
) %>%
summarise(n = n()) %>%
ungroup() %>%
group_by(.data$datetime) %>%
mutate(
ratio = .data$n/sum(.data$n)
) %>%
ungroup()
}
get_charging_rates_distribution(evsim::california_ev_sessions)
devtools::load_all(".")
source("~/Resourcefully Dropbox/Marc Canigueral/PROJECTS/R PACKAGES/evsim/R/simulation.R", echo=TRUE)
devtools::load_all(".")
devtools::load_all(".")
get_charging_rates_distribution(evsim::california_ev_sessions, unit = "year)
get_charging_rates_distribution(evsim::california_ev_sessions, unit = "year")
pkgdown::build_site()
devtools::release()
pkgdown::build_reference()
devtools::release()
