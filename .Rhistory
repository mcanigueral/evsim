ev_model <- read_ev_model(file = temp_model_file)
expect_equal(class(ev_model), "evmodel")
})
get_user_profiles_distribution(ev_model)
ev_model$models$time_cycle
test_that("User profiles distribution is printed correctly", {
upd <- get_user_profiles_distribution(ev_model)
expect_true(is_tibble(upd))
})
add_charging_infrastructure(sessions, 15)
#'
#' @return tibble
#' @export
#'
#' @importFrom dplyr %>% tibble mutate select all_of row_number filter group_by summarise
#' @importFrom tidyr separate
#' @importFrom lubridate as_datetime tz
#' @importFrom purrr map_dbl
#' @importFrom rlang .data
#'
add_charging_infrastructure <- function(sessions, resolution, min_stations = 0, names_prefix = NULL, connections_th = 10) {
# Consider that all sessions are in the same charging hub that we want to size
sessions <- sessions %>%
mutate(ChargingHub = "CH1")
# How many charging stations (of two sockets) do we need?
connections <- get_n_connections(sessions, resolution = resolution, by = "ChargingHub")
connections_pct <- tibble(
n_connections = seq(1, max(connections$n_connections))
) %>%
mutate(
n = map_dbl(.data$n_connections, ~ sum(connections$n_connections >= .x)),
pct = n/nrow(connections)*100
)
n_connections_required <- connections_pct %>%
filter(.data$pct > connections_th)
n_required_stations <- ceiling(max(n_connections_required$n_connections)/2)
if (n_required_stations < min_stations) {
n_required_stations <- min_stations
}
# Name the charging stations and the corresponding sockets
if (is.null(names_prefix)) {
names_prefix <- ""
}
new_stations_names <- paste(names_prefix, 1:n_required_stations, sep = "CHS")
socket_names <- paste(new_stations_names, rep(c(1, 2), each = n_required_stations), sep = "-")
# Iterate over all time slots assigning every session to a charging socket
free_sockets <- socket_names
sessions_socket <- sessions %>% mutate(idx = row_number())
sessions_socket$ChargingSocket <- NA
dttm_seq <- sort(unique(c(sessions$ConnectionStartDateTime, sessions$ConnectionEndDateTime)))
for (dttm in dttm_seq) {
# dttm <- connections$datetime[60]
# Add the sockets of ending sessions to the vector of free sockets
ending_sessions <- sessions_socket %>%
filter(
.data$ConnectionEndDateTime == dttm
) %>%
drop_na()
if (nrow(ending_sessions) > 0) {
free_sockets <- c(free_sockets, ending_sessions$ChargingSocket)
}
# Assign to the starting sessions the free sockets
starting_sessions <- sessions_socket %>%
filter(
.data$ConnectionStartDateTime == dttm
)
if (nrow(starting_sessions) > 0) {
n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
sessions_socket <- sessions_socket %>%
drop_na(.data$ChargingSocket) %>%
separate(.data$ChargingSocket, into = c("ChargingStation", "Socket"), sep = "-")
message(paste("Discarded", round((1-nrow(sessions_socket)/nrow(sessions))*100, 2), "% of sessions due to infrastructure"))
return(sessions_socket)
}
add_charging_infrastructure(sessions, 15)
resolution = 15
sessions
min_stations = 0
names_prefix = NULL
connections_th = 10
# Consider that all sessions are in the same charging hub that we want to size
sessions <- sessions %>%
mutate(ChargingHub = "CH1")
# How many charging stations (of two sockets) do we need?
connections <- get_n_connections(sessions, resolution = resolution, by = "ChargingHub")
connections
# How many charging stations (of two sockets) do we need?
connections <- sessions %>%
mutate(Profile = "n_connections") %>%
get_n_connections(sessions, resolution = resolution, by = "Profile")
# How many charging stations (of two sockets) do we need?
connections <- sessions %>%
mutate(Profile = "n_connections") %>%
get_n_connections(resolution = resolution, by = "Profile")
# How many charging stations (of two sockets) do we need?
connections <- sessions %>%
mutate(Profile = "n_connections") %>%
get_n_connections(resolution = resolution, by = "Profile")
connections
connections_pct <- tibble(
n_connections = seq(1, max(connections$n_connections))
) %>%
mutate(
n = map_dbl(.data$n_connections, ~ sum(connections$n_connections >= .x)),
pct = n/nrow(connections)*100
)
n_connections_required <- connections_pct %>%
filter(.data$pct > connections_th)
n_required_stations <- ceiling(max(n_connections_required$n_connections)/2)
if (n_required_stations < min_stations) {
n_required_stations <- min_stations
}
# Name the charging stations and the corresponding sockets
if (is.null(names_prefix)) {
names_prefix <- ""
}
new_stations_names <- paste(names_prefix, 1:n_required_stations, sep = "CHS")
socket_names <- paste(new_stations_names, rep(c(1, 2), each = n_required_stations), sep = "-")
# Iterate over all time slots assigning every session to a charging socket
free_sockets <- socket_names
sessions_socket <- sessions %>% mutate(idx = row_number())
sessions_socket$ChargingSocket <- NA
dttm_seq <- sort(unique(c(sessions$ConnectionStartDateTime, sessions$ConnectionEndDateTime)))
for (dttm in dttm_seq) {
# dttm <- connections$datetime[60]
# Add the sockets of ending sessions to the vector of free sockets
ending_sessions <- sessions_socket %>%
filter(
.data$ConnectionEndDateTime == dttm
) %>%
drop_na()
if (nrow(ending_sessions) > 0) {
free_sockets <- c(free_sockets, ending_sessions$ChargingSocket)
}
# Assign to the starting sessions the free sockets
starting_sessions <- sessions_socket %>%
filter(
.data$ConnectionStartDateTime == dttm
)
if (nrow(starting_sessions) > 0) {
n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
library(tidyr)
for (dttm in dttm_seq) {
# dttm <- connections$datetime[60]
# Add the sockets of ending sessions to the vector of free sockets
ending_sessions <- sessions_socket %>%
filter(
.data$ConnectionEndDateTime == dttm
) %>%
drop_na()
if (nrow(ending_sessions) > 0) {
free_sockets <- c(free_sockets, ending_sessions$ChargingSocket)
}
# Assign to the starting sessions the free sockets
starting_sessions <- sessions_socket %>%
filter(
.data$ConnectionStartDateTime == dttm
)
if (nrow(starting_sessions) > 0) {
n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
sessions_socket <- sessions_socket %>%
drop_na(.data$ChargingSocket) %>%
separate(.data$ChargingSocket, into = c("ChargingStation", "Socket"), sep = "-")
message(paste("Discarded", round((1-nrow(sessions_socket)/nrow(sessions))*100, 2), "% of sessions due to infrastructure"))
nrow(sessions_socket)
add_charging_infrastructure(sessions, connections_th = 0)
#'
#' @return tibble
#' @export
#'
#' @importFrom dplyr %>% tibble mutate select all_of row_number filter group_by summarise
#' @importFrom tidyr separate drop_na
#' @importFrom lubridate as_datetime tz
#' @importFrom purrr map_dbl
#' @importFrom rlang .data
#'
add_charging_infrastructure <- function(sessions, resolution = 15, min_stations = 0, names_prefix = NULL, connections_th = 10) {
# How many charging stations (of two sockets) do we need?
connections <- sessions %>%
mutate(Profile = "n_connections") %>%
get_n_connections(resolution = resolution, by = "Profile")
connections_pct <- tibble(
n_connections = seq(1, max(connections$n_connections))
) %>%
mutate(
n = map_dbl(.data$n_connections, ~ sum(connections$n_connections >= .x)),
pct = n/nrow(connections)*100
)
n_connections_required <- connections_pct %>%
filter(.data$pct > connections_th)
n_required_stations <- ceiling(max(n_connections_required$n_connections)/2)
if (n_required_stations < min_stations) {
n_required_stations <- min_stations
}
# Name the charging stations and the corresponding sockets
if (is.null(names_prefix)) {
names_prefix <- ""
}
new_stations_names <- paste(names_prefix, 1:n_required_stations, sep = "CHS")
socket_names <- paste(new_stations_names, rep(c(1, 2), each = n_required_stations), sep = "-")
# Iterate over all time slots assigning every session to a charging socket
free_sockets <- socket_names
sessions_socket <- sessions %>% mutate(idx = row_number())
sessions_socket$ChargingSocket <- NA
dttm_seq <- sort(unique(c(sessions$ConnectionStartDateTime, sessions$ConnectionEndDateTime)))
for (dttm in dttm_seq) {
# dttm <- connections$datetime[60]
# Add the sockets of ending sessions to the vector of free sockets
ending_sessions <- sessions_socket %>%
filter(
.data$ConnectionEndDateTime == dttm
) %>%
drop_na()
if (nrow(ending_sessions) > 0) {
free_sockets <- c(free_sockets, ending_sessions$ChargingSocket)
}
# Assign to the starting sessions the free sockets
starting_sessions <- sessions_socket %>%
filter(
.data$ConnectionStartDateTime == dttm
)
if (nrow(starting_sessions) > 0) {
n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
sessions_socket <- sessions_socket %>%
drop_na(.data$ChargingSocket) %>%
separate(.data$ChargingSocket, into = c("ChargingStation", "Socket"), sep = "-")
message(paste("Discarded", round((1-nrow(sessions_socket)/nrow(sessions))*100, 2), "% of sessions due to infrastructure"))
return(sessions_socket)
}
add_charging_infrastructure(sessions, connections_th = 0)
usethis::use_test("charging_infrastructure")
# Get the example `evmodel` and `sessions` included in the package
sessions <- evsim::california_ev_sessions %>%
filter(year(ConnectionStartDateTime) == 2018, month(ConnectionStartDateTime) == 10)
test_that("charging infrastructure sizing works", {
sessions_infrastructure <- add_charging_infrastructure(sessions, connections_th = 0)
expect_true(length(unique(sessions_infrastructure$ChargingStation)) > 1)
})
#'
#' @return tibble
#' @export
#'
#' @importFrom dplyr %>% tibble mutate select all_of row_number filter group_by summarise
#' @importFrom tidyr separate drop_na
#' @importFrom lubridate as_datetime tz
#' @importFrom purrr map_dbl
#' @importFrom rlang .data
#'
add_charging_infrastructure <- function(sessions, resolution = 15, min_stations = 0, names_prefix = NULL, connections_th = 10) {
# How many charging stations (of two sockets) do we need?
connections <- sessions %>%
mutate(Profile = "n_connections") %>%
get_n_connections(resolution = resolution, by = "Profile")
connections_pct <- tibble(
n_connections = seq(1, max(connections$n_connections))
) %>%
mutate(
n = map_dbl(.data$n_connections, ~ sum(connections$n_connections >= .x)),
pct = n/nrow(connections)*100
)
n_connections_required <- connections_pct %>%
filter(.data$pct > connections_th)
n_required_stations <- ceiling(max(n_connections_required$n_connections)/2)
if (n_required_stations < min_stations) {
n_required_stations <- min_stations
}
# Name the charging stations and the corresponding sockets
if (is.null(names_prefix)) {
names_prefix <- ""
}
new_stations_names <- paste(names_prefix, 1:n_required_stations, sep = "CHS")
socket_names <- paste(new_stations_names, rep(c(1, 2), each = n_required_stations), sep = "-")
# Iterate over all time slots assigning every session to a charging socket
free_sockets <- socket_names
sessions_socket <- sessions %>% mutate(idx = row_number())
sessions_socket$ChargingSocket <- NA
dttm_seq <- sort(unique(c(sessions$ConnectionStartDateTime, sessions$ConnectionEndDateTime)))
for (dttm in dttm_seq) {
# dttm <- connections$datetime[60]
# Add the sockets of ending sessions to the vector of free sockets
ending_sessions <- sessions_socket %>%
filter(
.data$ConnectionEndDateTime == dttm
) %>%
drop_na()
if (nrow(ending_sessions) > 0) {
free_sockets <- c(free_sockets, ending_sessions$ChargingSocket)
}
# Assign to the starting sessions the free sockets
starting_sessions <- sessions_socket %>%
filter(
.data$ConnectionStartDateTime == dttm
)
if (nrow(starting_sessions) > 0) {
n_free_sockets <- length(free_sockets)
if (n_free_sockets == 0) {
next
}
n_assigned_sockets <- pmin(nrow(starting_sessions), n_free_sockets)
sessions_socket$ChargingSocket[
starting_sessions$idx[1:n_assigned_sockets]
] <- free_sockets[1:n_assigned_sockets]
# Remove the assigned sockets from the vector of free sockets
if (n_assigned_sockets < n_free_sockets) {
free_sockets <- free_sockets[(n_assigned_sockets+1):n_free_sockets]
} else {
free_sockets <- c()
}
}
}
sessions_socket <- sessions_socket %>%
drop_na("ChargingSocket") %>%
separate("ChargingSocket", into = c("ChargingStation", "Socket"), sep = "-")
message(paste("Discarded", round((1-nrow(sessions_socket)/nrow(sessions))*100, 2), "% of sessions due to infrastructure"))
return(sessions_socket)
}
test_that("charging infrastructure sizing works", {
sessions_infrastructure <- add_charging_infrastructure(sessions, connections_th = 0)
expect_true(length(unique(sessions_infrastructure$ChargingStation)) > 1)
})
usethis::use_testthat()
upd
# Get the example `evmodel` and `sessions` included in the package
ev_model <- evsim::california_ev_model
upd <- get_user_profiles_distribution(ev_model)
upd
expect_equal(c("time_cycle", "profile", "ratio"), colnames(upd))
test_that("User profiles distribution is printed correctly", {
upd <- get_user_profiles_distribution(ev_model)
expect_equal(c("time_cycle", "profile", "ratio"), colnames(upd))
})
devtools::spell_check()
goodpractice::gp()
seq(1:5)
1:5
seq_len(5)
goodpractice::gp()
usethis::use_github_action("test-coverage")
library(covr)
covr::codecov(token = "6767f211-6948-4df9-817a-9fa76b67fdd7")
charging_rates <- sessions %>%
get_charging_rates_distribution()
charging_rates
expect_true(nrow(charging_rates) > 1)
ev_model$models
ev_model$models$user_profiles[[1]]
ev_model$models$user_profiles[[1]]$energy_models[[1]]
# Modify to assume that energy models from Worktime are for 11 kW
ev_model$models$user_profiles[[2]]$energy_models
# Modify to assume that energy models from Worktime are for 11 kW
ev_model$models$user_profiles[[2]]$energy_models[[1]]$charging_rate <- 11
ev_model$models$user_profiles[[2]]$energy_models[[1]]
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(15, 10)
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 11, 3.7)
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
simulated_sessions
ev_model$models$user_profiles[[1]]$energy_models
ev_model$models$user_profiles[[1]]
# Modify to assume that energy models from Worktime sessions are for 11 kW
ev_model$models$user_profiles[[1]]$energy_models[[2]]$charging_rate <- 11
ev_model
ev_model$models$user_profiles[[1]]
ev_model$models$user_profiles[[1]]$energy_models
simulated_sessions <- simulate_sessions(
ev_model,
sessions_day = tibble(
time_cycle = c("Workday", "Weekend"),
n_sessions = c(15, 10)
),
user_profiles = tibble(
time_cycle = c("Workday", "Workday", "Weekend"),
profile = c("Visit", "Worktime", "Visit"),
ratio = c(0.5, 0.5, 1),
power = c(3.7, 11, 3.7)
),
charging_powers = tibble(
power = c(3.7, 11),
ratio = c(0.3, 0.7)
),
dates = seq.Date(today(), today()+days(4), length.out = 4),
resolution = 15
)
simulated_sessions
simulated_sessions %>% filter(Profile == "Worktime", Power < 11)
test_that("demand calculation is skipped if there are no sessions", {
demand <- sessions %>%
mutate(Profile = "All") %>%
filter(Profile == "all") %>%
get_demand(by = "Profile", resolution = 15, dttm_seq = NULL)
expect_true(is.null(demand))
})
test_that("multiprocessing settings are correct", {
demand <- sessions %>%
mutate(Profile = "All") %>%
get_demand(by = "Profile", resolution = 15, mc.cores = 0)
expect_true("All" %in% names(demand))
demand <- sessions %>%
mutate(Profile = "All") %>%
get_demand(by = "Profile", resolution = 15, mc.cores = 10)
expect_true("All" %in% names(demand))
})
devtools::check_win_devel()
devtools::check_rhub()
expect_equal(class(ev_model), "evmodel")
devtools::check_win_devel()
pkgdown::build_site()
pkgdown::build_site()
devtools::check_win_devel()
pkgdown::build_site()
devtools::check_win_devel()
devtools::check_win_devel()
evsim::california_ev_sessions
evsim::california_ev_sessions[100, ]
get_demand(
evsim::california_ev_sessions[100, ],
by = "Session",
resolution = 60
)
library(evsim)
get_demand(
evsim::california_ev_sessions[100, ],
by = "Session",
resolution = 60
)
get_demand(
evsim::california_ev_sessions[1000, ],
by = "Session",
resolution = 60
)
get_demand(
evsim::california_ev_sessions[seq_len(100), ],
by = "Session",
resolution = 60
)
head(evsim::california_ev_sessions, 100)
devtools::check_win_devel()
